<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Jeu de la Vie</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      background: #0a0a0f;
      color: #e0e0e0;
      font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
      height: 100vh;
      overflow: hidden;
      display: flex;
      flex-direction: column;
    }

    .toolbar {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 10px 16px;
      background: #141420;
      border-bottom: 1px solid #2a2a3a;
      flex-wrap: wrap;
      z-index: 10;
    }

    .toolbar h1 {
      font-size: 16px;
      font-weight: 600;
      color: #8b5cf6;
      margin-right: 8px;
      white-space: nowrap;
    }

    .toolbar button {
      padding: 6px 14px;
      border: 1px solid #3a3a4a;
      border-radius: 6px;
      background: #1e1e2e;
      color: #e0e0e0;
      font-size: 13px;
      cursor: pointer;
      transition: all 0.15s;
      white-space: nowrap;
    }

    .toolbar button:hover {
      background: #2a2a3e;
      border-color: #8b5cf6;
    }

    .toolbar button.active {
      background: #8b5cf6;
      border-color: #8b5cf6;
      color: #fff;
    }

    .toolbar .sep {
      width: 1px;
      height: 24px;
      background: #2a2a3a;
    }

    .toolbar label {
      font-size: 12px;
      color: #888;
      display: flex;
      align-items: center;
      gap: 6px;
      white-space: nowrap;
    }

    .toolbar input[type="range"] {
      width: 80px;
      accent-color: #8b5cf6;
    }

    .toolbar select {
      padding: 4px 8px;
      border: 1px solid #3a3a4a;
      border-radius: 6px;
      background: #1e1e2e;
      color: #e0e0e0;
      font-size: 13px;
      cursor: pointer;
    }

    .info-bar {
      display: flex;
      align-items: center;
      gap: 16px;
      padding: 4px 16px;
      background: #111118;
      border-bottom: 1px solid #1e1e2e;
      font-size: 11px;
      color: #666;
    }

    .info-bar span {
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .info-bar .dot {
      width: 6px;
      height: 6px;
      border-radius: 50%;
      background: #8b5cf6;
    }

    .info-bar .dot.alive {
      background: #22c55e;
    }

    .canvas-container {
      flex: 1;
      overflow: hidden;
      position: relative;
      cursor: crosshair;
    }

    canvas {
      display: block;
      image-rendering: pixelated;
    }

    .patterns-panel {
      position: absolute;
      top: 8px;
      right: 8px;
      background: #141420ee;
      border: 1px solid #2a2a3a;
      border-radius: 8px;
      padding: 10px;
      display: none;
      max-height: calc(100vh - 120px);
      overflow-y: auto;
      z-index: 5;
      width: 200px;
    }

    .patterns-panel.open {
      display: block;
    }

    .patterns-panel h3 {
      font-size: 12px;
      color: #8b5cf6;
      margin-bottom: 8px;
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    .patterns-panel .pattern-btn {
      display: block;
      width: 100%;
      padding: 6px 8px;
      margin-bottom: 4px;
      text-align: left;
      border: 1px solid transparent;
      border-radius: 4px;
      background: transparent;
      color: #ccc;
      font-size: 12px;
      cursor: pointer;
      transition: all 0.15s;
    }

    .patterns-panel .pattern-btn:hover {
      background: #1e1e2e;
      border-color: #3a3a4a;
    }

    .patterns-panel .pattern-btn.selected {
      background: #2a2a3e;
      border-color: #8b5cf6;
      color: #fff;
    }

    .toast {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%) translateY(60px);
      background: #1e1e2eee;
      border: 1px solid #3a3a4a;
      padding: 8px 16px;
      border-radius: 8px;
      font-size: 13px;
      color: #e0e0e0;
      opacity: 0;
      transition: all 0.3s ease;
      z-index: 100;
      pointer-events: none;
    }

    .toast.show {
      opacity: 1;
      transform: translateX(-50%) translateY(0);
    }
  </style>
</head>
<body>

<div class="toolbar">
  <h1>Jeu de la Vie</h1>
  <div class="sep"></div>
  <button id="btn-play">&#9654; Play</button>
  <button id="btn-step">&#9197; Step</button>
  <button id="btn-clear">&#9724; Clear</button>
  <button id="btn-random">&#127922; Random</button>
  <div class="sep"></div>
  <label>Vitesse
    <input type="range" id="speed" min="1" max="60" value="12">
    <span id="speed-val">12 fps</span>
  </label>
  <div class="sep"></div>
  <label>Taille
    <select id="cell-size">
      <option value="4">4px</option>
      <option value="6">6px</option>
      <option value="8" selected>8px</option>
      <option value="10">10px</option>
      <option value="16">16px</option>
    </select>
  </label>
  <label>Couleur
    <input type="color" id="cell-color" value="#8b5cf6">
  </label>
  <div class="sep"></div>
  <button id="btn-patterns">Patterns</button>
</div>

<div class="info-bar">
  <span><span class="dot alive"></span> Cellules: <b id="cell-count">0</b></span>
  <span><span class="dot"></span> Gnration: <b id="gen-count">0</b></span>
  <span id="status-text">En pause  cliquez pour dessiner</span>
</div>

<div class="canvas-container" id="container">
  <canvas id="canvas"></canvas>
  <div class="patterns-panel" id="patterns-panel">
    <h3>Patterns</h3>
  </div>
</div>

<div class="toast" id="toast"></div>

<script>
(function() {
  // --- State ---
  let cellSize = 8;
  let cols, rows;
  let grid, nextGrid;
  let running = false;
  let generation = 0;
  let fps = 12;
  let lastFrame = 0;
  let cellColor = '#8b5cf6';
  let drawing = false;
  let drawValue = 1;
  let selectedPattern = null;
  let panX = 0, panY = 0;
  let isPanning = false;
  let panStart = { x: 0, y: 0 };

  // --- DOM ---
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');
  const container = document.getElementById('container');
  const btnPlay = document.getElementById('btn-play');
  const btnStep = document.getElementById('btn-step');
  const btnClear = document.getElementById('btn-clear');
  const btnRandom = document.getElementById('btn-random');
  const btnPatterns = document.getElementById('btn-patterns');
  const speedSlider = document.getElementById('speed');
  const speedVal = document.getElementById('speed-val');
  const cellSizeSelect = document.getElementById('cell-size');
  const cellColorInput = document.getElementById('cell-color');
  const cellCountEl = document.getElementById('cell-count');
  const genCountEl = document.getElementById('gen-count');
  const statusText = document.getElementById('status-text');
  const patternsPanel = document.getElementById('patterns-panel');

  // --- Patterns ---
  const patterns = {
    'Glider': [[0,1],[1,2],[2,0],[2,1],[2,2]],
    'LWSS': [[0,1],[0,4],[1,0],[2,0],[2,4],[3,0],[3,1],[3,2],[3,3]],
    'Blinker': [[0,0],[0,1],[0,2]],
    'Toad': [[0,1],[0,2],[0,3],[1,0],[1,1],[1,2]],
    'Beacon': [[0,0],[0,1],[1,0],[2,3],[3,2],[3,3]],
    'Pulsar': (function() {
      const p = [];
      const offsets = [
        [0,2],[0,3],[0,4],[0,8],[0,9],[0,10],
        [2,0],[3,0],[4,0],[2,5],[3,5],[4,5],
        [2,7],[3,7],[4,7],[2,12],[3,12],[4,12],
        [5,2],[5,3],[5,4],[5,8],[5,9],[5,10],
        [7,2],[7,3],[7,4],[7,8],[7,9],[7,10],
        [8,0],[9,0],[10,0],[8,5],[9,5],[10,5],
        [8,7],[9,7],[10,7],[8,12],[9,12],[10,12],
        [12,2],[12,3],[12,4],[12,8],[12,9],[12,10]
      ];
      return offsets;
    })(),
    'Pentadecathlon': [[0,4],[1,4],[2,3],[2,5],[3,4],[4,4],[5,4],[6,4],[7,3],[7,5],[8,4],[9,4]],
    'Gosper Glider Gun': (function() {
      const cells = [
        [0,24],[1,22],[1,24],[2,12],[2,13],[2,20],[2,21],[2,34],[2,35],
        [3,11],[3,15],[3,20],[3,21],[3,34],[3,35],[4,0],[4,1],[4,10],
        [4,16],[4,20],[4,21],[5,0],[5,1],[5,10],[5,14],[5,16],[5,17],
        [5,22],[5,24],[6,10],[6,16],[6,24],[7,11],[7,15],[8,12],[8,13]
      ];
      return cells;
    })(),
    'Block': [[0,0],[0,1],[1,0],[1,1]],
    'Beehive': [[0,1],[0,2],[1,0],[1,3],[2,1],[2,2]],
    'Loaf': [[0,1],[0,2],[1,0],[1,3],[2,1],[2,3],[3,2]],
    'R-pentomino': [[0,1],[0,2],[1,0],[1,1],[2,1]],
    'Diehard': [[0,6],[1,0],[1,1],[2,1],[2,5],[2,6],[2,7]],
    'Acorn': [[0,1],[1,3],[2,0],[2,1],[2,4],[2,5],[2,6]],
  };

  // --- Init ---
  function initGrid() {
    cols = Math.ceil(canvas.width / cellSize);
    rows = Math.ceil(canvas.height / cellSize);
    const newGrid = new Uint8Array(cols * rows);
    if (grid) {
      const oldCols = Math.floor(grid.length > 0 ? grid.length / (rows || 1) : 0);
      // try to preserve old state — skip on resize mismatch
    }
    grid = newGrid;
    nextGrid = new Uint8Array(cols * rows);
    generation = 0;
    updateInfo();
  }

  function resizeCanvas() {
    canvas.width = container.clientWidth;
    canvas.height = container.clientHeight;
    initGrid();
    render();
  }

  // --- Core Game of Life ---
  function idx(x, y) {
    return y * cols + x;
  }

  function countNeighbors(x, y) {
    let count = 0;
    for (let dy = -1; dy <= 1; dy++) {
      for (let dx = -1; dx <= 1; dx++) {
        if (dx === 0 && dy === 0) continue;
        const nx = (x + dx + cols) % cols;
        const ny = (y + dy + rows) % rows;
        count += grid[idx(nx, ny)];
      }
    }
    return count;
  }

  function step() {
    for (let y = 0; y < rows; y++) {
      for (let x = 0; x < cols; x++) {
        const i = idx(x, y);
        const neighbors = countNeighbors(x, y);
        const alive = grid[i];
        if (alive) {
          nextGrid[i] = (neighbors === 2 || neighbors === 3) ? 1 : 0;
        } else {
          nextGrid[i] = (neighbors === 3) ? 1 : 0;
        }
      }
    }
    [grid, nextGrid] = [nextGrid, grid];
    generation++;
    updateInfo();
  }

  // --- Rendering ---
  function hexToRgb(hex) {
    const r = parseInt(hex.slice(1, 3), 16);
    const g = parseInt(hex.slice(3, 5), 16);
    const b = parseInt(hex.slice(5, 7), 16);
    return { r, g, b };
  }

  function render() {
    ctx.fillStyle = '#0a0a0f';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Grid lines (subtle)
    if (cellSize >= 6) {
      ctx.strokeStyle = '#1a1a25';
      ctx.lineWidth = 0.5;
      ctx.beginPath();
      for (let x = 0; x <= cols; x++) {
        ctx.moveTo(x * cellSize + 0.5, 0);
        ctx.lineTo(x * cellSize + 0.5, rows * cellSize);
      }
      for (let y = 0; y <= rows; y++) {
        ctx.moveTo(0, y * cellSize + 0.5);
        ctx.lineTo(cols * cellSize, y * cellSize + 0.5);
      }
      ctx.stroke();
    }

    // Cells
    const { r, g, b } = hexToRgb(cellColor);
    const imgData = ctx.getImageData(0, 0, canvas.width, canvas.height);
    const data = imgData.data;

    for (let y = 0; y < rows; y++) {
      for (let x = 0; x < cols; x++) {
        if (grid[idx(x, y)]) {
          const px = x * cellSize;
          const py = y * cellSize;
          const size = cellSize - (cellSize >= 6 ? 1 : 0);
          for (let dy = 0; dy < size; dy++) {
            for (let dx = 0; dx < size; dx++) {
              const pi = ((py + dy) * canvas.width + (px + dx)) * 4;
              if (pi >= 0 && pi < data.length - 3) {
                data[pi] = r;
                data[pi + 1] = g;
                data[pi + 2] = b;
                data[pi + 3] = 255;
              }
            }
          }
        }
      }
    }

    ctx.putImageData(imgData, 0, 0);

    // Ghost pattern preview
    if (selectedPattern && ghostPos) {
      const pat = patterns[selectedPattern];
      ctx.fillStyle = cellColor + '55';
      for (const [py, px] of pat) {
        const gx = ghostPos.x + px;
        const gy = ghostPos.y + py;
        if (gx >= 0 && gx < cols && gy >= 0 && gy < rows) {
          ctx.fillRect(
            gx * cellSize,
            gy * cellSize,
            cellSize - (cellSize >= 6 ? 1 : 0),
            cellSize - (cellSize >= 6 ? 1 : 0)
          );
        }
      }
    }
  }

  // --- Info ---
  function updateInfo() {
    let count = 0;
    for (let i = 0; i < grid.length; i++) count += grid[i];
    cellCountEl.textContent = count;
    genCountEl.textContent = generation;
    statusText.textContent = running
      ? 'Simulation en cours...'
      : 'En pause — cliquez pour dessiner';
  }

  // --- Animation Loop ---
  function loop(time) {
    if (running) {
      const interval = 1000 / fps;
      if (time - lastFrame >= interval) {
        step();
        render();
        lastFrame = time;
      }
    }
    requestAnimationFrame(loop);
  }

  // --- Mouse/Touch Interaction ---
  let ghostPos = null;

  function getCellCoords(e) {
    const rect = canvas.getBoundingClientRect();
    const x = Math.floor((e.clientX - rect.left) / cellSize);
    const y = Math.floor((e.clientY - rect.top) / cellSize);
    return { x: Math.max(0, Math.min(cols - 1, x)), y: Math.max(0, Math.min(rows - 1, y)) };
  }

  canvas.addEventListener('mousedown', function(e) {
    if (e.button === 1 || (e.button === 0 && e.altKey)) {
      isPanning = true;
      panStart = { x: e.clientX, y: e.clientY };
      return;
    }

    const { x, y } = getCellCoords(e);

    if (selectedPattern) {
      placePattern(x, y);
      render();
      return;
    }

    drawing = true;
    drawValue = grid[idx(x, y)] ? 0 : 1;
    grid[idx(x, y)] = drawValue;
    render();
    updateInfo();
  });

  canvas.addEventListener('mousemove', function(e) {
    const coords = getCellCoords(e);

    if (selectedPattern) {
      ghostPos = coords;
      if (!running) render();
    }

    if (!drawing) return;
    const { x, y } = coords;
    grid[idx(x, y)] = drawValue;
    if (!running) render();
    updateInfo();
  });

  canvas.addEventListener('mouseup', function() {
    drawing = false;
    isPanning = false;
  });

  canvas.addEventListener('mouseleave', function() {
    drawing = false;
    ghostPos = null;
    if (!running) render();
  });

  // Touch support
  canvas.addEventListener('touchstart', function(e) {
    e.preventDefault();
    const touch = e.touches[0];
    const { x, y } = getCellCoords(touch);

    if (selectedPattern) {
      placePattern(x, y);
      render();
      return;
    }

    drawing = true;
    drawValue = grid[idx(x, y)] ? 0 : 1;
    grid[idx(x, y)] = drawValue;
    render();
    updateInfo();
  }, { passive: false });

  canvas.addEventListener('touchmove', function(e) {
    e.preventDefault();
    if (!drawing) return;
    const touch = e.touches[0];
    const { x, y } = getCellCoords(touch);
    grid[idx(x, y)] = drawValue;
    if (!running) render();
    updateInfo();
  }, { passive: false });

  canvas.addEventListener('touchend', function() {
    drawing = false;
  });

  // --- Pattern placement ---
  function placePattern(cx, cy) {
    if (!selectedPattern) return;
    const pat = patterns[selectedPattern];
    for (const [py, px] of pat) {
      const x = (cx + px + cols) % cols;
      const y = (cy + py + rows) % rows;
      grid[idx(x, y)] = 1;
    }
    updateInfo();
    toast('Pattern "' + selectedPattern + '" plac');
  }

  // --- Controls ---
  btnPlay.addEventListener('click', function() {
    running = !running;
    btnPlay.textContent = running ? '\u23F8 Pause' : '\u25B6 Play';
    btnPlay.classList.toggle('active', running);
    updateInfo();
  });

  btnStep.addEventListener('click', function() {
    if (!running) {
      step();
      render();
    }
  });

  btnClear.addEventListener('click', function() {
    grid.fill(0);
    generation = 0;
    running = false;
    btnPlay.textContent = '\u25B6 Play';
    btnPlay.classList.remove('active');
    updateInfo();
    render();
  });

  btnRandom.addEventListener('click', function() {
    for (let i = 0; i < grid.length; i++) {
      grid[i] = Math.random() < 0.15 ? 1 : 0;
    }
    generation = 0;
    updateInfo();
    render();
    toast('Grille gnre alatoirement');
  });

  speedSlider.addEventListener('input', function() {
    fps = parseInt(this.value);
    speedVal.textContent = fps + ' fps';
  });

  cellSizeSelect.addEventListener('change', function() {
    cellSize = parseInt(this.value);
    resizeCanvas();
    toast('Taille: ' + cellSize + 'px');
  });

  cellColorInput.addEventListener('input', function() {
    cellColor = this.value;
    if (!running) render();
  });

  // --- Patterns Panel ---
  btnPatterns.addEventListener('click', function() {
    patternsPanel.classList.toggle('open');
    btnPatterns.classList.toggle('active', patternsPanel.classList.contains('open'));
  });

  function buildPatternsPanel() {
    let html = '<h3>Patterns</h3>';
    html += '<button class="pattern-btn' + (!selectedPattern ? ' selected' : '') + '" data-pattern="">&#9997; Dessin libre</button>';
    for (const name in patterns) {
      html += '<button class="pattern-btn" data-pattern="' + name + '">' + name + '</button>';
    }
    patternsPanel.innerHTML = html;

    patternsPanel.querySelectorAll('.pattern-btn').forEach(function(btn) {
      btn.addEventListener('click', function() {
        const name = this.dataset.pattern;
        selectedPattern = name || null;
        patternsPanel.querySelectorAll('.pattern-btn').forEach(function(b) {
          b.classList.remove('selected');
        });
        this.classList.add('selected');
        if (selectedPattern) {
          toast('Pattern: ' + selectedPattern + '  cliquez pour placer');
          canvas.style.cursor = 'cell';
        } else {
          toast('Mode dessin libre');
          canvas.style.cursor = 'crosshair';
        }
      });
    });
  }

  // --- Toast ---
  function toast(msg) {
    const el = document.getElementById('toast');
    el.textContent = msg;
    el.classList.add('show');
    clearTimeout(el._timeout);
    el._timeout = setTimeout(function() {
      el.classList.remove('show');
    }, 2000);
  }

  // --- Keyboard shortcuts ---
  document.addEventListener('keydown', function(e) {
    if (e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT') return;
    switch(e.key) {
      case ' ':
        e.preventDefault();
        btnPlay.click();
        break;
      case 'n':
      case 'N':
        btnStep.click();
        break;
      case 'c':
      case 'C':
        btnClear.click();
        break;
      case 'r':
      case 'R':
        btnRandom.click();
        break;
      case 'Escape':
        selectedPattern = null;
        canvas.style.cursor = 'crosshair';
        patternsPanel.querySelectorAll('.pattern-btn').forEach(function(b) {
          b.classList.remove('selected');
        });
        const freeBtn = patternsPanel.querySelector('[data-pattern=""]');
        if (freeBtn) freeBtn.classList.add('selected');
        toast('Mode dessin libre');
        break;
    }
  });

  // --- Resize ---
  let resizeTimeout;
  window.addEventListener('resize', function() {
    clearTimeout(resizeTimeout);
    resizeTimeout = setTimeout(function() {
      const oldGrid = grid;
      const oldCols = cols;
      const oldRows = rows;
      resizeCanvas();
      // Restore cells that fit
      for (let y = 0; y < Math.min(oldRows, rows); y++) {
        for (let x = 0; x < Math.min(oldCols, cols); x++) {
          grid[idx(x, y)] = oldGrid[y * oldCols + x];
        }
      }
      render();
    }, 100);
  });

  // --- Start ---
  buildPatternsPanel();
  resizeCanvas();
  requestAnimationFrame(loop);
  toast('Espace = Play/Pause | N = Step | R = Random | C = Clear');
})();
</script>
</body>
</html>
